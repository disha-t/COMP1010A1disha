package doNotModify;

/* autogenerated by Processing revision 1293 on 2024-02-20 */
import processing.core.*;

import toDo.ToDo;

public class WordGame extends PApplet {
  String letters;

  public void setup() {
    background(255);
    /* size commented out by preprocessor */;
    letterBank = generateLetterBank();
    reset();
    ToDo.words = CSVReader.read("data/words.txt");
    timeStarted = millis();
  }

  public void reset() {
    letters = generateString(MAX_LETTERS);
    finalize = false;
    wordMade = "";
    lastIndex = -1;
  }

  public static String letterBank = "";

  public static String generateLetterBank() {
    // English alphabet
    String alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    // Typical frequency distribution of letters in English
    int[] typicalFrequencies = {
            130, 91, 81, 75, 70, 67, 63, 61, 60, 43,
            40, 28, 27, 25, 24, 22, 20, 20, 19, 15,
            10, 8, 2, 1, 1, 1, 1
    };

    String result = "";
    for(int i = 0; i < alphabet.length(); i++) {
      for(int k = 0; k < typicalFrequencies[i]; k++) {
        result+=alphabet.charAt(i);
      }
    }
    return result;
  }

  public static String generateString(int n) {
    String result = "";
    for(int i=0; i < n-2; i++) {
      char ch = letterBank.charAt((int) (Math.random() * letterBank.length()));
      result += ch;
      if(ch == 'Q') {
        if(result.length() == n) { //can't do Q if you can't do U
          result = result.substring(0, result.length() - 1);
          i--;
        }
        else {
          result += "U";
          i++;
        }
      }
    }
    if(ToDo.countVowels(result) < result.length()/3) {
      return generateString(n);
    }
    return result+".";
  }

  int score = 0;
  String lastWordMade = "";
  public static int minLetters = 3;
  public static int minLettersBonus = 4;
  public static final int MAX_TIME = 90 * 1000;
  public static final int END_GAME_TIME = 3000;
  public static final int MAX_LETTERS = 8;

  public void draw() {
    if(millis() - timeStarted > MAX_TIME) {
      gameOver = true;
      background(0);
      fill(240, 240, 80);
      textAlign(CENTER, CENTER);
      textSize(100);
      text("GAME OVER\nScore: "+score, width/2, height/2);
      if(millis() - timeStarted > MAX_TIME + END_GAME_TIME) {
        exit();
      }
    }
    else {
      drawMenu();
      if(finalize) {
        int pointsToDisplay = (int)Math.pow(2, wordMade.length());
        textAlign(CENTER, CENTER);
        if(ToDo.isValid(wordMade, minLetters) || ToDo.match(wordMade, minLetters)!=null) {
          fill(0, 200, 0);
          textSize(80);
          if(sortedBonusApplies(wordMade, minLettersBonus)) {
            pointsToDisplay+=4*(int)Math.pow(2, wordMade.length());
            if(palindromeBonusApplies(wordMade, minLettersBonus)) {
              pointsToDisplay+=4*(int)Math.pow(2, wordMade.length());
              text(wordMade+": "+pointsToDisplay+" points\nSORTED AND PALIDNROME WORD BONUS APPLIED!", width/2, height/2); //will never happen
            }
            else {
              text(wordMade+": "+pointsToDisplay+" points\nSORTED WORD BONUS APPLIED!", width/2, height/2);
            }
          }
          else {
            if(palindromeBonusApplies(wordMade, minLettersBonus)) {
              pointsToDisplay+=4*(int)Math.pow(2, wordMade.length());
              text(wordMade+": "+pointsToDisplay+" points\nPALINDROME WORD BONUS APPLIED!", width/2, height/2);
            }  
            else {
              if(!ToDo.isValid(wordMade, minLetters)) {
                wordMade = ToDo.match(wordMade, minLetters);
              }
              text(wordMade+": +"+pointsToDisplay+" points", width/2, height/2);
            }
          }
        }
        else {
          fill(255, 0, 0);
          textSize(100);
          text(wordMade+": -"+pointsToDisplay+" points", width/2, height/2);
        }
      }
      else {
        drawLetters(letters, height/3, 0);
        drawLetters(wordMade, 2*height/3, 100);
      }
    }
  }

  public void drawMenu() {
    background(255);
      fill(0, 0, 100);
      textSize(50);
      textAlign(LEFT, TOP);
      text("Score: "+score+"\nTime left: "+(int)((MAX_TIME-millis()+timeStarted)/1000), 10, 10);
      textSize(20);
      textAlign(RIGHT, TOP);
      text("Minimum letters to get points is "+minLetters+"\nScore for a valid word: +2 to the power of word length\nScore for invalid word: -2 to the power of word length\nQUADRUPLE-POINT bonus for sorted (asc/desc) words with min 4 letters\nPress the letter icon or key to select letter\nPress ENTER to finalize word\nPress BACKSPACE TO put letter back\nPress '0' if you cannot make a word to cop a 5-point penalty and move on\n Dot can be used as wildcard (but no bonus if you do that)", width-10, 10);
  }

  public static boolean sortedBonusApplies(String s, int minCharacters) {
    return s.indexOf('.') < 0 && ToDo.isSorted(s) && s.length() >= minCharacters;
  }

  public static boolean palindromeBonusApplies(String s, int minCharacters) {
    return s.indexOf('.') < 0 && ToDo.isPalindrome(s) && s.length() >= minCharacters;
  }

  public static final int DIAMETER = 100;

  public void drawLetters(String letters, int y, int shade) {
    textAlign(CENTER, CENTER);
    textSize(80);
    for (int i = 0; i < letters.length(); i++) {
      // textSize(44 + (int)(letters.charAt(i)-65));
      // fill(shade);
      // circle((i + 1) * width / (letters.length() + 1) , y, DIAMETER);
      if(ToDo.isVowel(letters.charAt(i))) {
        fill(255, 100, 100);
      }
      else {
        fill(100, 100, 255);
      }
      text(letters.charAt(i), (i + 1) * width / (letters.length() + 1) , y);
    }
  }

  boolean gameOver = false;
  int column;
  String wordMade = "";
  boolean finalize = false;
  int lastIndex = -1;

  float timeStarted = 0;

  public void keyPressed() {
    print(key);
    if(gameOver) {
      return;
    }
    else if(key == '0') {
      score -= 5;
      reset();
    }
    else if(keyCode == BACKSPACE) {
      if(wordMade.length() > 0) {
        int idx = letters.indexOf(' ');
        if(idx >= 0) {
          letters = letters.substring(0, idx) + wordMade.charAt(wordMade.length() - 1) + letters.substring(idx + 1);
          wordMade = wordMade.substring(0, wordMade.length() - 1);
        }
      }
    }
    else {
      if(keyCode == ENTER && wordMade.length() > 0) {
        if(finalize) {
          reset();
        }
        else {
          finalize = true;
          if(ToDo.isValid(wordMade, minLetters) || ToDo.match(wordMade, minLetters)!=null) {
            score += (int)Math.pow(2, wordMade.length());
            if(sortedBonusApplies(wordMade, minLettersBonus)) {
              score+=(int)Math.pow(2, wordMade.length())*4; //sorted bonus
            }
          }
          else {
            score -= (int)Math.pow(2, wordMade.length());
          }
        }
      }
      else if(key=='.' && letters.indexOf('.') >= 0) {
        addToWord(letters.indexOf(key));
      }
      else {
        if(letters.indexOf((key+"").toUpperCase())>=0) {
          addToWord(letters.indexOf((key+"").toUpperCase()));
        } 
      }
    }
  }

  public void mouseClicked() {
    column = -1;
    if(mouseY > height / 2 - 50 && mouseY < height / 2 + 50) {
      for (int i = 0; i < letters.length(); i++) {
        if(mouseX > (i + 1) * width / (letters.length() + 1) - DIAMETER/2 && mouseX < (i + 1) * width / (letters.length() + 1) + DIAMETER/2) {
          if(letters.charAt(i) != ' ') {
            addToWord(i);
            return;
          }
        }
      }
    }
  }

  public void addToWord(int i) {
    lastIndex = i;
    wordMade += letters.charAt(i);
    letters = letters.substring(0, i) + " " + letters.substring(i + 1);
  }

  public void settings() { 
    size(1600, 900); 
  }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "doNotModify.WordGame" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
